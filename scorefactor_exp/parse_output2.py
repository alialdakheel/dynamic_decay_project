"""
Parse exp_output directory (output files generated by StarExec)
"""

import os
from pathlib import Path
import numpy as np
import pandas as pd

DEBUG = False

def parse_one(path):
    with open(path, 'r') as fp:
        level_list = list()
        glue_list = list()
        for line in fp:
            if line[-2] == '%':
                level = int(line.split()[5])
                level_list.append(level)
                glue = int(line.split()[11])
                glue_list.append(glue)
            if "total real time since initialization:" in line:
                solve_time = float(line.split()[7])
            if "SATISFIABLE" in line:
                sat_state = line.split()[2]
    average_level = sum(level_list)/len(level_list)
    if DEBUG:
        print(path)
        print("average level:", average_level)
        print("solve time:", solve_time)

    return level_list, solve_time, sat_state, glue_list

def parse_all(output_dir, path_dict, cnfs):
    res_dict = dict()
    for cnf in cnfs:
        res_dict[cnf] = dict()
        for c in path_dict.keys():
            f = list(filter(lambda x: cnf in x, path_dict[c]))
            assert(len(f) == 1)
            path = f[0]
            try:
                level_list, solve_time, satstate, glue_list = parse_one(path)
            except Exception as e:
                if DEBUG:
                    print("Parse one failed", path)
                    print(e)
                continue
            res_dict[cnf][c] = {
                    'level': level_list,
                    'time': solve_time,
                    'sat_state': satstate,
                    'glue': max(glue_list),
                    }

    return res_dict

def parse_exp_output(output_dir):
    dir_tree = os.walk(output_dir)
    path_list = [f"{t[0]}/{f}" for t in dir_tree for f in t[2] if f[-4:]==".txt"]
    config_list = sorted(list(set([p.split('/')[-3] for p in path_list])))
    cnfs = [p.split('/')[-2] for p in path_list]
    cnfs = list(set(cnfs))
    path_dict = {c:[path for path in path_list if c in path] for c in config_list}

    res_dict = parse_all(output_dir, path_dict, cnfs)
    return res_dict, config_list

def dict_to_df(res_dict, explode_level=True):
    df = pd.DataFrame.from_records(
            [
                (
                    cnf,
                    c,
                    r_dict['level'],
                    np.mean(r_dict['level']),
                    r_dict['time'],
                    r_dict['sat_state'],
                    r_dict['glue']
                )
                for cnf, c_dict in res_dict.items()
                for c, r_dict in c_dict.items()
            ],
            columns=[
                'cnf',
                'config',
                'level',
                'av_level',
                'time',
                'sat_state',
                'glue'
                ]
    )

    if explode_level:
        df = df.explode('level')
        df.level = df.level.astype(int)

    df.time = df.time.astype(float)
    df['config_state'] = df.config.str.cat(df.sat_state, sep=', ')

    return df

def dict_to_dfs(res_dict):
    dfs = list()
    for conf, res_tuple in res_dict.items():
        paths = list(res_tuple[0].keys())
        levels = list(res_tuple[0].values())
        times = list(res_tuple[1].values())
        df = pd.DataFrame({
            "path": paths,
            "level": levels,
            "time": times
            })
        df = df.explode('level')
        df.level = df.level.astype(int)
        df.time = df.time.astype(float)
        dfs.append(df)
    return dfs

if __name__ == "__main__":
    exp_outputs_dir = "exp_output"
    res_dict = parse_exp_output(exp_outputs_dir)
    df, conf_list = dict_to_df(res_dict)


